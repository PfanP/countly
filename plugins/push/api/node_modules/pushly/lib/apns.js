'use strict';

var util = require('util'),
	merge = require('merge'),
	EventEmitter = require('events').EventEmitter,
	Err = require('./error.js'),
	constants = require('./constants'),
	DEFAULTS = constants.OPTIONS,
	EVENTS = constants.SP,
	debug = constants.debug('APNS'),
	fs = require('fs'),
	net = require('net'),
	tls = require('tls'),
	LRU = require('lru-cache'),
	Dequeue = require('dequeue'),
	retry = require('retry'),
	q = require('q');

var certificates;

var APNS = function(credentials){
	if (false === (this instanceof APNS)) {
        return new APNS(credentials);
    }

	this.options = merge({}, DEFAULTS, credentials);

	// Buffer for ready to send notifications [uint32 notification id, device, data]
	this.notifications = new Dequeue();

	this.currentId = 0;

	EventEmitter.call(this);

	this.init();
};
util.inherits(APNS, EventEmitter);

APNS.prototype.init = function () {
	if (this.initDeferred) {
		return this.initDeferred.promise;
	}

	if (!certificates) {
		certificates = LRU({
			max: this.options.apnsCertificatesCache,
		});
	}

	debug('Initialising APNS');
	this.initDeferred = q.defer();

	// Read certificate
	this.certificate = certificates.get(this.options.key);
	if (!this.certificate) {
		if (typeof this.options.key === 'string') {
			debug('Reading key');
			fs.readFile(this.options.key, function (err, data) {
				debug('Reading key done with error %j, data %j', err, typeof data);
				if (err) {
					this.initDeferred.reject(err);
					return;
				}
				this.certificate = data;
				certificates.set(this.options.key, this.certificate);
				this.initDeferred.resolve();
			}.bind(this));
		} else if (this.options.key instanceof Buffer) {
			this.certificate = this.options.key;

			process.nextTick(function(){
				this.initDeferred.resolve();
			}.bind(this));
		} else {
			process.nextTick(function(){
				this.initDeferred.reject(new Err(Err.CREDENTIALS, 'Cannot read certificate from ' + this.options.key));
			}.bind(this));
		}
	} else {
		process.nextTick(function(){
			this.initDeferred.resolve();
		}.bind(this));
	}

	return this.initDeferred.promise;
};

/**
 * Handle a particular error type: either just emit it, or remove a message from queue completely
 * @private
 */
APNS.prototype.handlerr = function (note, code, name, messageId, deviceTokens) {
	debug('Handling error code %d, name %j for note %j, message ID %j, device tokens %j', code, name, note, messageId, deviceTokens);

	var err = new Err(code, name, messageId, deviceTokens), que, notification;

	if (code === Err.TOKEN) {
		this.emit(EVENTS.ERROR, err);
	} else if (code & Err.IS_RECOVERABLE) {
		// if (this.socket && this.socket.notifications) while (this.socket.notifications.length) {
		// 	this.notifications.push(this.socket.notifications.shift());
  //           debug('Putting back device id %j', noteDevice(this.notifications.last()));
		// }
		this.emit(EVENTS.ERROR, err);
	} else if (code & Err.IS_NON_RECOVERABLE) {

		if (code === Err.CREDENTIALS) {
			clearFromCredentials(this.options.key);
			this.closed = true;
		}

		if (this.socket && this.socket.notifications) {
			debug('Putting %d notifications back to queue (now %d)', this.socket.notifications.length, this.notifications.length);
            que = new FixedSizeDequeue(this.options.apnsNotificationCacheForErrorPurposes);
			while (this.socket.notifications.length) {
				notification = this.socket.notifications.shift();
				if (noteMessageId(notification) !== messageId) {
					que.push(notification);
				}
			}
			this.socket.notifications = que;
        }
        if (this.notifications.length) {
        	debug('Going to remove some of %d notifications in queue', this.notifications.length);
        	if (messageId) {
	            que = new Dequeue();
	            var removed = 0, lastMessageId;
				while (this.notifications.length) {
					notification = this.notifications.shift();
					if (noteMessageId(notification) !== messageId) {
						que.push(notification);
					} else {
						removed++;
						lastMessageId = noteMessageId(notification);
					}
				}
				debug('Removing %d notifications from queue (%d left)', removed, que.length);
				this.notifications = que;

				if (removed === 1) {
					err.messageId = lastMessageId;
				}
        	} else {
				notification = this.notifications.shift();
				err.messageId = noteMessageId(notification);
				debug('Removing %d notifications from queue (message %d is responsible)', this.notifications.length + 1, err.messageId);
        		this.notifications = new Dequeue(); 
        	}
		}

		this.emit(EVENTS.ERROR, err);
	}

	if (!(err.code & Err.IS_SKIPPABLE)) {
//		this.end();
		this.socket = null;
		this.connectDeferred = null;
	}

	this.serviceImmediate();

	return err;
};

/**
 * You should never need to call this method, initialisation and connection is handled by {@link Connection#pushNotification}
 * @private
 */
APNS.prototype.connect = function () {
	if (this.connectDeferred) {
		return this.connectDeferred.promise;
	}

	if (this.closed) {
		debug('Skipped socket creation on closed connection');
		var defer = q.defer();
		defer.reject(new Err(Err.CONNECTION, 'Connection closed'));
		return defer.promise;
	}

	debug('Initialising connection with options %j', this.options);
	this.connectDeferred = q.defer();

	this.init().then(function () {
		var socketOptions = {
			pfx: this.certificate,
			passphrase: this.options.passphrase,
			socket: new net.Stream()
		}, timeoutRef;

		var sock = tls.connect(
			this.options.port,
			this.options.gateway,
			socketOptions,
			function () {
				if (sock.timedout) {
					sock.destroy();
				} else if (this.connectDeferred) {
                	if (timeoutRef) {
                		clearTimeout(timeoutRef);
                	}
                    debug('Connection established');
                    this.connectDeferred.resolve();
                    if (!this.socket.notifications) {
	                    this.socket.notifications = new FixedSizeDequeue(this.options.apnsNotificationCacheForErrorPurposes);
                    }
                }
			}.bind(this));

		this.socket = sock;
		this.socket.setNoDelay(false);
		this.socket.setTimeout(this.options.connectionTTL);

		socketOptions.socket.on('error', this.onSocketError.bind(this));
		this.socket.on('error', this.onSocketError.bind(this));
		this.socket.on('timeout', this.onSocketTimeout.bind(this));
		this.socket.on('data', this.onSocketData.bind(this));
		this.socket.on('drain', this.onSocketDrain.bind(this, true));
		this.socket.on('clientError', this.onSocketError.bind(this));
		this.socket.once('close', this.onSocketClose.bind(this));

		socketOptions.socket.connect(this.options.port, this.options.gateway);

		// Ensure that connection won't stuck at connecting stage
		timeoutRef = setTimeout(function(){
			if (this.connectDeferred && this.connectDeferred.promise.isPending()) {
				if (this.socket) {
					this.socket.timedout = true;
				}
				this.connectDeferred.reject(this.handlerr(null, Err.CONNECTION, 'Connection timed out'));
			}
			timeoutRef = undefined;
		}.bind(this), this.options.connectionConnectTimeout);

	}.bind(this)).fail(function (error) {
		debug('Initialisation error:', error);
		this.connectDeferred.reject(this.handlerr(null, Err.CREDENTIALS, error));
		// this.socket.end();
	}.bind(this));

	return this.connectDeferred.promise;
};

APNS.prototype.connectWithBackoff = function(){
	debug('connectWithBackoff');

	if (this.connectDeferred && !this.connectDeferred.promise.isPending()) {
		this.connectDeferred = null;
	}

	var defer = q.defer();
	if (this.closed) {
		debug('Skipped socket creation on closed connection');
		defer.reject(new Error('Connection closed'));
		return defer.promise;
	} else {
		var operation = retry.operation({
			retries: 3
		});
		operation.attempt(function(attempt){
			debug('Connecting ... (attempt ' + attempt + ')');

			this.connect().delay(2000).then(function(){
				debug('Done with attempt ' + attempt + ', socket ' + !!this.socket);
				if (!this.socket || !this.socket.writable) {
					var err = new Err(Err.CONNECTION, 'Socket closed immediately after being open');

					if (operation.retry(err)) {
						debug('Retrying connection X');
						return;
					} else {
						debug('All retries are done, raising error ' + operation.mainError());

						var main = operation.mainError();
						if (main && main.code === Err.CONNECTION) {
							debug('Won\'t retry connectning because socket was closing immediately after connection');
							this.abortAll(Err.CONNECTION | Err.CREDENTIALS, 'Unable to connect to APN after several retries');
							defer.reject(new Err(Err.CONNECTION | Err.CREDENTIALS, 'Unable to connect to APN after several retries'));
						} else {
							defer.reject(err);
						}
					}
				} else {
					debug('Connected with backoff');
					defer.resolve();
				}
			}.bind(this)).fail(function(err){
				debug('Failed to connect with backoff: %j', err);

				this.connectDeferred = null;

				if (err) {
					if (err.code & Err.IS_RECOVERABLE) {
						if (operation.retry(err)) {
							debug('Retrying connection Y');
							return;
						}
					}
				} else {
					if (operation.retry(err)) {
						debug('Retrying connection Z');
						return;
					}
				}

				defer.reject(operation.mainError());
				// this.handlerr();
            }.bind(this));
		}.bind(this));
	}

	this.connectWithBackoffDeferred = defer;

	return defer.promise;
};

// -------------------------------------------------------------------------------
// --------------- Socket event handlers -----------------------------------------
// -------------------------------------------------------------------------------

/**
 * @private
 */
APNS.prototype.onSocketError = function(err) {
	debug('Socket error occurred', err);

	if (this.connectDeferred && this.connectDeferred.promise.isPending()) {
		this.connectDeferred.reject(new Err(Err.CONNECTION, err));
		return;
	}

	if (!this.socket) {
		this.handlerr(last, Err.CONNECTION, err, noteMessageId(last));
		return;
	}

	if (this.socket.transmissionErrorOccurred && err.code == 'EPIPE') {
		debug('EPIPE occurred after a transmission error which we can ignore');
		return;
	}

	var last;
	if (this.socket.busy) {
		// A notification was in flight. It should be buffered for resending.
		last = this.socket.notifications.last();
		if (last) {
			this.notifications.push(last);
			debug('Putting back last notification on socket error: %j', noteDevice(last));
            this.emit(EVENTS.MESSAGE, noteMessageId(last), -1);
			this.handlerr(last, Err.CONNECTION, err, noteMessageId(last));
			return;
		}
	}

	this.handlerr(last, Err.CONNECTION, err, noteMessageId(last));
};

/**
 * @private
 */
 APNS.prototype.onSocketTimeout = function() {
	debug('Socket timeout');
	if (this.socket && this.socket.notifications && this.socket.notifications.length) {
		this.handlerr(null, Err.CONNECTION, 'Socket timeout');
	} else if (!this.closed) {
		this.closed = true;
		this.serviceImmediate();
	}
};

/**
 * @private
 */
APNS.prototype.onSocketData = function (data) {
	if (data[0] === 8) {
		var code = data[1], identifier = data.readUInt32BE(2), note, errorNote, err,
			que = new FixedSizeDequeue(this.options.apnsNotificationCacheForErrorPurposes);

		debug('Notification %d caused an error: %d', identifier, code);

		while (this.socket.notifications.length) {
			note = this.socket.notifications.shift();
			if (noteId(note) === identifier) {
				errorNote = note;
				break;
			} else {
				que.push(note);
			}
		}

		if (errorNote) {
			debug('Device ID to unset is %j', noteDevice(errorNote));
		}

		debug('Scrolled %d notifications, %d left, first is %j, last is %j', que.length, this.socket.notifications.length, noteDevice(this.socket.notifications.first()), noteDevice(this.socket.notifications.last()));
		debug('APN (%d) first is %j, last is %j', this.notifications.length, noteDevice(this.notifications.first()), noteDevice(this.notifications.last()));

		if (noteDevice(this.socket.notifications.first()) === noteDevice(this.socket.notifications.last())) {
			debug('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! OOPP');
			var q = new FixedSizeDequeue(this.options.apnsNotificationCacheForErrorPurposes);
			while (this.socket.notifications.length) {
				note = this.socket.notifications.shift();
				debug('%j / %j', noteId(note), noteDevice(note));
				q.push(note);
			}
			this.socket.notifications = q;
		}

		if (!errorNote) {
			this.socket.notifications = que;

			if (this.socket.notifications.length > 0) {
				var differentialSize = noteId(this.socket.notifications[0]) - identifier;

				this.options.apnsNotificationCacheForErrorPurposes += differentialSize * 2;
				this.socket.notifications.size = this.options.apnsNotificationCacheForErrorPurposes;

				debug('Increased apnsNotificationCacheForErrorPurposes to %d', this.options.apnsNotificationCacheForErrorPurposes);
			}
		}

		var prevMessageId, count = 0;
		while (this.socket.notifications.length) {
			note = this.socket.notifications.pop();

			if (prevMessageId && prevMessageId !== noteMessageId(note)) {
				this.emit(EVENTS.MESSAGE, prevMessageId, count);
				prevMessageId = noteMessageId(note);
				count = -1;
			} else if (!prevMessageId) {
				prevMessageId = noteMessageId(note);
				count--;
			} else {
				count--;
			}
			this.notifications.unshift(note);
		}
		if (prevMessageId) {
	        this.emit(EVENTS.MESSAGE, noteMessageId(note), count);
		}

		debug('Done putting back (%d), first is %j, last is %j', this.socket.notifications.length, noteDevice(this.socket.notifications.first()), noteDevice(this.socket.notifications.last()));
		debug('APN (%d) first is %j, last is %j', this.notifications.length, noteDevice(this.notifications.first()), noteDevice(this.notifications.last()));

		if (code === 1) {
			err = this.handlerr(errorNote, Err.CONNECTION, 'APNS Processing error', noteMessageId(errorNote));
		} else if (code === 2) {
			err = this.handlerr(errorNote, Err.TOKEN, 'APNS Missing device token', noteMessageId(errorNote), errorNote ? [{bad: noteDevice(errorNote)}] : []);
		} else if (code === 3) {
			err = this.handlerr(errorNote, Err.MESSAGE, 'APNS Missing topic', noteMessageId(errorNote));
		} else if (code === 4) {
			err = this.handlerr(errorNote, Err.MESSAGE, 'APNS Missing payload', noteMessageId(errorNote));
		} else if (code === 5) {
			err = this.handlerr(errorNote, Err.TOKEN, 'APNS Invalid token size', noteMessageId(errorNote), errorNote ? [{bad: noteDevice(errorNote)}] : []);
		} else if (code === 6) {
			err = this.handlerr(errorNote, Err.MESSAGE, 'APNS Invalid topic size', noteMessageId(errorNote));
		} else if (code === 7) {
			err = this.handlerr(errorNote, Err.MESSAGE, 'APNS Invalid payload size', noteMessageId(errorNote));
		} else if (code === 8) {
			err = this.handlerr(errorNote, Err.TOKEN, 'APNS Invalid token', noteMessageId(errorNote), errorNote ? [{bad: noteDevice(errorNote)}] : []);
		} else if (code === 10) {
			err = this.handlerr(errorNote, Err.CONNECTION, 'APNS Shutdown', noteMessageId(errorNote));
		} else {
			err = this.handlerr(errorNote, Err.CONNECTION, 'APNS Unknown Error', noteMessageId(errorNote));
		}

		if (err.code & Err.IS_SKIPPABLE) {
			this.socket.transmissionErrorOccurred = true;
		}
	}
};

/**
 * @private
 */
APNS.prototype.onSocketDrain = function(serviceBuffer) {
	debug('Socket drained');
	this.emit(EVENTS.MESSAGE, noteMessageId(this.socket.notifications.last()));
	this.socket.busy = false;

	if (serviceBuffer === true) {
		this.serviceImmediate();
	}
};

/**
 * @private
 */
APNS.prototype.onSocketClose = function() {
	debug('Socket closed with connectDeferred ' + !!this.connectDeferred + ' / ' + (this.connectDeferred && this.connectDeferred.promise.isPending()) + ' and backoffDeferred ' + !!this.connectWithBackoffDeferred + ' / ' + (this.connectWithBackoffDeferred && this.connectWithBackoffDeferred.promise.isPending()));

	if (this.closed) {
		this.emit(EVENTS.CLOSED, this);
		return;
	} else if (this.connectWithBackoffDeferred && this.connectWithBackoffDeferred.promise.isPending()) {
		debug('Wating for next connection');
		this.socket = null;
		return;
		// just wait for backoff
	} else if (this.connectDeferred && this.connectDeferred.promise.isPending()) {
		debug('Connection error occurred before TLS Handshake');
		this.connectDeferred.reject(new Error('Unable to connect'));
	} else {
		var last;
		if (this.socket.busy) {
			// A notification was in flight. It should be buffered for resending.
			last = this.socket.notifications.last();
			if (last) {
                this.emit(EVENTS.MESSAGE, noteMessageId(last), -1);
				debug('Putting back last notification on socket close: %j', noteDevice(last));
				this.notifications.push(last);
			}
		}

		this.handlerr(last, Err.CONNECTION, 'Socket closed');
	}

	this.serviceImmediate();
};

/**
 * @private
 */
APNS.prototype.destroySocket = function(destroying) {
	if (this.socket) {
		if (destroying) {
			debug('Destroying socket');
			this.socket.destroy();
		} else {
			debug('Ending socket');
			this.socket.end();
		}
	} else {
		debug('Socket has been already destroyed / ended');
	}
};

/**
 * @private
 */
APNS.prototype.service = function() {
	debug('%d left to send', this.notifications.length);

	if (this.closed) {
		debug('Connection is closed');
		this.destroySocket(false);
		return;
	}

	if (!this.socket) {
		if ((!this.connectWithBackoffDeferred || !this.connectWithBackoffDeferred.promise.isPending()) && this.notifications.length) {
			// Sending again after long period of inactivity
			debug('Initiating connection with backoff');
			this.connectWithBackoff().then(this.service.bind(this));
		}
	} else if (!this.socket.writable || this.socket.busy) {
		// Socket is not ready yet, do nothing
	} else if (this.socket.notifications && this.notifications.length) {
		// Socket is ready to go, send notification

		this.socket.busy = true;

        var notification;
		if (DEFAULTS.apnsTransmitAtOnce > 1) {
	        debug('Transmitting %d notifications', Math.min(DEFAULTS.apnsTransmitAtOnce, this.notifications.length));

	        var count = 0, prevMessageId, waitForDrain;
			for (var i = 0; i < DEFAULTS.apnsTransmitAtOnce && this.notifications.length > 0; i++) {
				notification = this.notifications.shift();
				this.socket.notifications.push(notification);

				if (!this.socket.write(noteData(notification))) {
					waitForDrain = true;
	        		debug('Failed to write to the socket, wating for next drain (%d / %d)', this.socket.notifications.length, this.notifications.length);
					break;
				}

				// Only emit when message ID changes in buffer
				if (prevMessageId && prevMessageId !== noteMessageId(this.socket.notifications.last())) {
					this.emit(EVENTS.MESSAGE, prevMessageId, count);
					prevMessageId = noteMessageId(this.socket.notifications.last());
					count = 1;
				} else if (!prevMessageId) {
					prevMessageId = noteMessageId(this.socket.notifications.last());
					count++;
				} else {
					count++;
				}
			}

			if (prevMessageId) {
				this.emit(EVENTS.MESSAGE, prevMessageId, count);
			} else {
				this.emit(EVENTS.MESSAGE, noteMessageId(notification), count);
			}

			this.socket.busy = false;
			if (!waitForDrain) {
				setTimeout(this.serviceImmediate.bind(this), DEFAULTS.apnsTransmitAtOnceDelay);
			}
			// this.serviceImmediate();
		} else {

			notification = this.notifications.shift();
			this.socket.notifications.push(notification);

	        debug('Transmitting notification to device %j', noteDevice(notification));

			if (this.socket.write(noteData(notification))) {
				this.onSocketDrain(true);
			}
		}

	}
};

/**
 * @private
 */
APNS.prototype.serviceImmediate = function() {
	if (!this.servicingImmediate) {
		this.servicingImmediate = true;
		setImmediate(function(){
			this.servicingImmediate = false;
			this.service();
		}.bind(this));
	}
};

// Helper methods to remind notification object indexes
var noteId = function(note){ return note ? note[0] : undefined; };
var noteDevice = function(note){ return note ? note[1] : undefined; };
var noteData = function(note){ return note ? note[2] : undefined; };
var noteMessageId = function(note){ return note ? note[3] : undefined; };

/**
 * Close socket immediately without wating for drain or response
 */
APNS.prototype.close = function (clb) {
	this.closed = true;
	this.serviceImmediate();
	if (clb) {
		var arr = [];
		while (this.notifications.length) {
			arr.push(this.notifications.shift());
		}
		clb(arr.length ? arr : undefined);
	}
};

/**
 * Remove all notifications for a particular message
 */
APNS.prototype.abort = function (message) {
	var que = new Dequeue(), notification;
	while (this.notifications.length) {
		notification = this.notifications.shift();
		if (noteMessageId(notification) !== message.id) {
			que.push(notification);
		}
	}
	debug('Left %d out of %d notifications in queue due to message abort', this.notifications.length, this.notifications.length + que.length);
	this.notifications = que;
	this.serviceImmediate();
};

/**
 * Remove all notifications for a particular message
 */
APNS.prototype.abortAll = function (code, name) {
	debug('Aborting all messages');
	var notification, messageIds = [];
	while (this.notifications.length) {
		notification = this.notifications.shift();
		if (messageIds.indexOf(noteMessageId(notification)) === -1) {
			messageIds.push(noteMessageId(notification));
		}
	}

	debug('Found %d messages to abort: %j', messageIds.length, messageIds);
	this.notifications = new Dequeue();

	for (var i in messageIds) {
		this.handlerr(null, code, name, messageIds[i]);
	}

	this.serviceImmediate();
};

/**
 * Whether this connection is not full of unsent messages
 */
APNS.prototype.free = function () {
	return this.notifications.length < this.options.queue;
};

/**
 * Queue a message for delivery to recipients
 * @param {String} content Compiled according to Apple guidelines message to send.
 * @param {String} encoding Encoding of message. Defaults to 'utf8', @see message.js.
 * @param {Date} expiry Expiry time of message. Defaults to 1 week from message creation, @see message.js.
 * @param {Buffer} device Buffer with device token.
 */
APNS.prototype.send = function (messageId, content, encoding, expiry, device, locale) {
	// debug('Sending message id %j content %j encoding %j expiry %j / %j device %j locale %j', messageId, content, encoding, expiry, expiry.getTime(), device, locale);
	if (!this.free() || this.closed) {
		debug('Won\'t send message id %j because socket is not free (%j) or closed (%j)', messageId, !this.free(), !!this.closed);
		return -1;
	}

	if (typeof content === 'string') {
		// do nothing
	} else if (locale) {
		if (content[locale]) {
			content = content[locale];
		} else if (content['default']) {
			content = content['default'];
		} else {
			this.handlerr([id, device, data, messageId], Err.MESSAGE, 'No default locale in localized message', messageId);
			return;
		}
	} else {
		if (content['default']) {
			content = content['default'];
		} else {
			this.handlerr([id, device, data, messageId], Err.MESSAGE, 'No locale provided for device when sending localized message', messageId);
			return;
		}
	}

	var id = this.currentId++;
	if (this.currentId > 0xffffffff) {
		this.currentId = 0;
	}

	var token = device;
	var contentLength = Buffer.byteLength(content, encoding);
	var position = 0;

	var data = new Buffer(1 + 4 + 4 + 2 + token.length + 2 + contentLength);
	// Command
	data[position] = 1;
	position++;

	// Identifier
	data.writeUInt32BE(id, position);
	position += 4;

	// Expiry
	data.writeUInt32BE(Math.floor(expiry.getTime() / 1000), position);
	position += 4;

	// Token Length
	data.writeUInt16BE(token.length, position);
	position += 2;
	// Device Token
	position += token.copy(data, position, 0);
	// Payload Length
	data.writeUInt16BE(contentLength, position);
	position += 2;
	//Payload
	position += data.write(content, position, encoding);

	this.add([id, device, data, messageId]);

	this.serviceImmediate();

	return id;
};


APNS.prototype.add = function (notification) {
	this.notifications.push(notification);
};

var FixedSizeDequeue = function(size){
	this.size = size;
	Dequeue.call(this);
};
FixedSizeDequeue.prototype = new Dequeue();
FixedSizeDequeue.prototype.push = function(d) {
	if (this.length >= this.size) {
		Dequeue.prototype.shift.apply(this);
	}
	Dequeue.prototype.push.apply(this, [d]);
};
FixedSizeDequeue.prototype.unshift = function(d) {
	if (this.length >= this.size) {
		Dequeue.prototype.pop.apply(this);
	}
	Dequeue.prototype.unshift.apply(this, [d]);
};

module.exports = APNS;

var clearFromCredentials = function(key) {
	if (certificates) {
		debug('clearFromCredentials %j / %j', key, certificates.keys());
		certificates.del(key);
	}
};

module.exports.clearFromCredentials = clearFromCredentials;

