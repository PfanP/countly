'use strict';

var util = require('util'),
	merge = require('merge'),
	LRU = require('lru-cache'),
	EventEmitter = require('events').EventEmitter,
	Err = require('./error.js'),
	M = require('./message.js'),
	constants = require('./constants'),
	EVENTS = constants.EVENTS,
	SP = constants.SP,
	DEFAULTS = constants.OPTIONS,
	debug = constants.debug('worker'),
	_ = require('lodash'),
	platforms = {};

platforms[M.Platform.APNS] = require('./apns.js');
platforms[M.Platform.GCM] = require('./gcm.js');

// /**
//  * Wrapper responsible for connection lifecycle, load balancing maintaining reasonable amount of concurrent connections
//  */
// var ConnectionWrapper = function(platform, size) {
// 	this.platform = platform;
// 	this.size = size;
// };

// ConnectionWrapper.prototype.grow = function(){
// };

// ConnectionWrapper.prototype.send = function(message, worker){
// 	var deviceCount = message.devices ? message.devices.length : worker.options.query.count(message.devicesQuery),
// 		connectionCount = deviceCount / 1000;

// 	if (connectionCount < 2) {
// 		connectionCount = 1;
// 	} else if (connectionCount > this.size) {
// 		connectionCount = this.size;
// 	}
// };

/**
 * Callbacks:
 * {
 * 		count()
 * }
 */
var PushlyWorker = function(opts, callbacks) {
	this.options = merge({}, DEFAULTS, opts);
	this.callbacks = callbacks;

	// Connections cache
	this.connections = LRU({
		max: this.options.connections,
		maxAge: this.options.connectionTTL,
		dispose: function(key, connection) {
			// actual socket will be alive until the latest message is sent
			connection.close();
		}
	});

	// Messages in processing hash {message.id: message}
 	this.messages = new Messages();

	// Last status update time for each message {message.id: timestamp}
 	this.messagesStatusTimes = {};

 	// Queue of messages still not in processing
	this.queue = new Queue();

	// Message results for limiting number of status updates {message.id: last sent message.result}
 	this.results = {};

	// Map of tasks clean up refs: {message.id: setTimeout ref}
	this.cleanUps = {};

	process.on('message', function(m){
		if (typeof this[m.cmd] === 'function') {
			debug('IPC message from master: %j', m);
			this[m.cmd](m);
		}
	}.bind(this));

    debug('Worker started %d', process.pid);
};
util.inherits(PushlyWorker, EventEmitter);

PushlyWorker.prototype.connect = function(message) {
	var connection = this.connections.get(message.credentialsId());

	if (!connection && this.connections.itemCount < this.options.connections) {
		connection = new platforms[message.credentials.platform](message.credentials);

		// Notification is sent (one or more tokens)
		connection.on(SP.MESSAGE, function(messageId, size){
            size = size || 1;
			debug('Batch sent for message %j: %d notifications', messageId, size);
			if (messageId in this.messages) {
				var msg = this.messages[messageId];
				msg.result.sent += size;
				msg.result.processed += size;
				this.updateMessage(msg);
			} else {
				debug('!!!!!!!!!!No message %j in process %d', messageId, process.id);
			}
		}.bind(this));

		connection.on(SP.ERROR, function(err){
			debug('Error for message: %j', err);

			if (err.messageId && err.messageId in this.messages) {
				this.updateMessage(this.messages[err.messageId], err);
			} else if (err.messageId) {
				debug('!!!!!!!!!!No message %j in process %d', err.messageId, process.id);
			}
		}.bind(this));

		connection.on(SP.CLOSED, function(connection){
			debug('Connection is closed, aborting all messages');
			for (var k in this.messages) {
				debug('Aborting message id %j: %j', k, this.messages[k]);

				var m = this.messages[k],
					c = this.connections.get(m.credentialsId());

				if (c === connection) {
					debug('Aborting message %j because connection is closed', m.id);
					m.result.status &= ~M.Status.InProcessing;
					m.result.status |= M.Status.Aborted;
					this.updateMessage(m, true);
				}
			}
		}.bind(this));

		if (!this.connections.set(message.credentialsId(), connection)) {
			connection.close();
			return undefined;
		}
	}
	return connection;
};

PushlyWorker.prototype.checkQueue = function(immediate) {
	debug('Checking queue');
	if (this.messages.length < this.options.connectionsPerCredentials) {
		var next = this.queue.next();
		if (next) {
			this.start(next);
		}
	} else {
		debug('Queue is full');
	}
	if (!immediate){
		setTimeout(1000, this.checkQueue.bind(this));
	}
};

PushlyWorker.prototype.sendToConnection = function(connection, message, content, encoding, expires, device, locale) {
	message.result.total += util.isArray(device) ? device.length : 1;
	if (typeof device === 'string' && message.credentials.platform === M.Platform.APNS) {
		device = new Buffer(device.replace(/[^0-9a-f]/gi, ''), 'hex');
	}
	connection.send(message.id, content, encoding, expires, device, locale);
};

PushlyWorker.prototype.startMessageStatusUpdater = function(message) {
	var self = this,
		f = function() {
			if (message.id in self.messages && (message.result.status & (M.Status.Done | M.Status.Aborted)) === 0) {
				self.updateMessage(message);
				setTimeout(f, self.options.statusUpdatePeriod);
			}
		};
	f();
};

PushlyWorker.prototype.start = function(message) {
	debug('Going to send message %j', message.id);
	this.messages.add(message);

	var connection = this.connect(message);
	if (connection) {
		var content = message.compile(message.credentials.platform),
			expires = message.expiryDate,
			encoding = message.content.encoding;

		debug('Starting message %j with content %j', message.id, content);

		var f = this.sendToConnection.bind(this, connection, message, content, encoding, expires);
		if (message.devices) {
			message.devices.forEach(f);
		} else {
			this.callbacks.stream(message, message.devicesQuery, f);
		}

		message.result.status |= M.Status.InProcessing;
		this.updateMessage(message, true);
		this.startMessageStatusUpdater(message);
	}
};

PushlyWorker.prototype.push = function(message) {
	debug('Pushing new message %j', message.id);
	this.messages.add(message);
	process.send({
		pid: process.pid,
		cmd: EVENTS.MASTER_SEND,
		message: message.serialize()
	});
};

PushlyWorker.prototype.abort = function(message) {
	debug('Aborting message %j from worker', message.id);
	process.send({
		pid: process.pid,
		cmd: EVENTS.MASTER_ABORT,
		messageId: message.id
	});
};

PushlyWorker.prototype.send = function(connection, messageId, content, expires, encoding, device) {
	connection.send(content, encoding, expires, device);
};

PushlyWorker.prototype.setCallbacks = function(callbacks) {
	this.callbacks = callbacks;
};

/**
 * Select a worker with connection open or least loaded worker and dispatch message to it.
 * @api private
 */
PushlyWorker.prototype[EVENTS.CHILD_PROCESS] = function(m) {
	var message = new M.Message(m.message);

	this.queue.add(message);
	this.checkQueue(true);
};

/**
 * Abort sending.
 * @api private
 */
PushlyWorker.prototype[EVENTS.CHILD_ABORT] = function(m) {
	var message = this.messages[m.messageId];
	if (message) {
		debug('Aborting message %j with status %j by master\'s order', m.messageId, message.result.status);
		var connection = this.connections.get(message.credentialsId());
		if (connection) {
			debug('Going to abort connection %j', connection);
			connection.abort(message);
		}
		message.result.status &= ~M.Status.InProcessing;
		message.result.status |= M.Status.Aborted;
		debug('Updating status of message %j with status %j', m.messageId, message.result.status);
		setTimeout(this.updateMessage.bind(this, message, true), 1000);
		// this.updateMessage(message, true);
	}
};

/**
 * Handle status update.
 * @api private
 */
PushlyWorker.prototype[EVENTS.CHILD_STATUS] = function(m) {
	debug('Emiting status: %j', m);
    if (m.messageId in this.messages) {
        this.messages[m.messageId].result = m.result;
        this.emit('status', this.messages[m.messageId]);
    } else {
    	debug('!!!!!!!!!!!!!!No message %j in messages of worker %d', m.messageId, process.pid);
    }
	// var message = this.messages[m.messageId], result = {status: M.Status.Aborted};
	// if (message) {
	// 	result = message.result;
	// }

	// process.send({
	// 	pid: process.pid,
	// 	cmd: EVENTS.MASTER_STATUS,
	// 	messageId: m.messageId,
	// 	result: message.result
	// });
};

/**
 * Update message internally and emit 'status' event
 * @api private
 */
PushlyWorker.prototype.updateMessage = function(message, immediate, error) {
	if (immediate instanceof Err) {
		error = immediate;
		immediate = error.code !== Err.TOKEN;
	}

	debug('Updating message in process %d: %j, %j, %j', process.pid, message, immediate, error);

	if (error) {
		if (error.code & Err.IS_NON_RECOVERABLE) {
			message.result.status |= M.Status.Error;
			message.result.error = error;

			message.result.status &= ~M.Status.InProcessing;
			message.result.status |= M.Status.Aborted | M.Status.Done;
            this.cleanupFromMessageId(message.id);
		} else if (error.code === Err.TOKEN) {
			message.result.sent -= error.deviceTokens.length;
			if (this.callbacks && this.callbacks.onInvalidToken) {
				error.deviceTokens = error.deviceTokens.map(function(t){
					var token = {};
					if (t.bad) token.bad = t.bad instanceof Buffer ? t.bad.toString() : t.bad;
					if (t.good) token.good = t.good instanceof Buffer ? t.good.toString() : t.good;
					return token;
				});
				this.callbacks.onInvalidToken(message, error.deviceTokens, error);
			}
			immediate = true;
		} else {
			message.result.status |= M.Status.Error;
			message.result.error = error;
		}
	}

	if (message.result.processed === message.result.total) {
		message.result.status &= ~M.Status.InProcessing;
		message.result.status |= M.Status.Done;
        this.cleanupFromMessageId(message.id);
	} else if (message.result.status & M.Status.Aborted) {
        this.cleanupFromMessageId(message.id);
	}

	if (immediate || !this.messagesStatusTimes || !this.messagesStatusTimes[message.id] || this.messagesStatusTimes[message.id] < (Date.now() - this.options.statusUpdatePeriod)) {
		if (message.id in this.messages) {
			this.messagesStatusTimes[message.id] = Date.now();
		}
		if (!(message.id in this.results) || !_.isEqual(message.result, this.results[message.id])) {
			this.results[message.id] = _.assign({}, message.result);
			process.send({
				pid: process.pid,
				cmd: EVENTS.MASTER_STATUS,
				messageId: message.id,
				result: message.result
			});
		}
		debug('Updated message in process %d with master notification: %j, %j, %j', process.pid, message, immediate, error);
	} else {
		debug('Updated message in process %d: %j, %j, %j (immediate %d, statusTimes %d)', process.pid, message, immediate, error, immediate, this.messagesStatusTimes[message.id] - (Date.now() - this.options.statusUpdatePeriod));
	}

};


/**
 * Remove message from private variables after 20 seconds delay (some device tokens might be not processed yet
 * @api private
 */
PushlyWorker.prototype.cleanupFromMessageId = function(messageId) {
	if (!(messageId in this.cleanUps)) {
		this.cleanUps[messageId] = setTimeout(function(){
	    	debug('Cleaning up message %j from worker %d', messageId, process.pid);
	    	if (this.messages[messageId]) this.updateMessage(this.messages[messageId], true);
	    	this.messages.remove(messageId);
        	delete this.messagesStatusTimes[messageId];
	    	debug('%d messages are in worker %d after cleanup: %j', this.messages.length, process.pid, this.messages);
    	}.bind(this), 20000);
	}
};

var Queue = function(){};
util.inherits(Queue, Array);
Queue.prototype.add = Array.prototype.push;
Queue.prototype.next = Array.prototype.shift;

var Messages = function(){
	Object.defineProperty(this, 'length', {
		enumerable: false,
		configurable: false,
		writable: true,
		value: 0
	});
    Object.defineProperties(this, {
        add: {
            value: function(message){
				if (!this[message.id]) {
					this.length++;
					this[message.id] = message;
				}
			}
        },
        has: {
            value: function(message){
				return (message.id || message) in this;
			}
        },
        remove: {
            value: function(message){
            	if (this[message.id || message]) {
            		this.length--;
            		delete this[message.id || message];
            	}
			}
        }
    });
};

module.exports = PushlyWorker;



